// Implementation file for Unsorted.h#include "unsorted.h"UnsortedType::UnsortedType(){  length = 0;}bool UnsortedType::IsFull() const{  return (length == MAX_ITEMS);}int UnsortedType::LengthIs() const{  return length;}void UnsortedType::RetrieveItem(ItemType& item, bool& found) // Pre:  Key member(s) of item is initialized. // Post: If found, item's key matches an element's key in the //       list and a copy of that element has been stored in item; //       otherwise, item is unchanged. {  bool moreToSearch;  int location = 0;  found = false;  moreToSearch = (location < length);  while (moreToSearch && !found)   {    switch (item.ComparedTo(info[location]))    {      case LESS    :       case GREATER : location++;                     moreToSearch = (location < length);                     break;      case EQUAL   : found = true;                     item = info[location];                     break;    }  }}void UnsortedType::InsertItem(ItemType item)// Post: item is in the list.{  info[length] = item;  length++;}void UnsortedType::DeleteItem_a(ItemType item)//function: item의 끝까지 비교후 있으면 삭제하고, 없으면 리스트가 변하지 않는다.// Pre:  item에 요소가 있어야함.// Post: item에 타깃요소가 삭제되고, 그 자리를 맨 마지막 요소가 채운다.{    bool deleted = false;    for (int i = 0; i < length && !deleted; i++) {        if (item.ComparedTo(info[i]) == EQUAL) {            info[i] = info[length - 1];            length--;            deleted = true;        }    }    /*  int location = 0;  while (item.ComparedTo(info[location]) != EQUAL) {        location++;        if (item.ComparedTo(info[location]) == EQUAL) {            info[location] = info[length - 1];            length--;        }        else continue;    }*/}void UnsortedType::DeleteItem_c(ItemType item)//function: item에서 타깃과 같은 요소를 삭제한다.// Pre:  item에 요소가 있어야함.// Post: item에서 타깃과 같은 요소를 삭제되고, 그 자리를 마지막 요소가 채운다.{    /*int location = 0;    while (location!=length-1) {        if (item.ComparedTo(info[location]) == EQUAL) {            info[location] = info[length - 1];            length--;        }        location++;    }*/    int l = 0;    while (l < length) {        if (item.ComparedTo(info[l]) == EQUAL) {            info[l] = info[length - 1];            length--;        }        else { l++; }    }}    void UnsortedType::ResetList()// Post: currentPos has been initialized.{  currentPos = -1;}void UnsortedType::GetNextItem(ItemType& item)// Post: item is current item.//       Current position has been updated.{  currentPos++;  item = info[currentPos];}